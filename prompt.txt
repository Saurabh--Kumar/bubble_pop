You are a powerful coding AI. Please generate a clean, extensible, SOLID-compliant, event-driven Python implementation of a game called bubble_pop. It uses MediaPipe for hand tracking and OpenCV for rendering and video capture.

ğŸ® Game Overview
The game uses the front camera to track a userâ€™s fists (center point). Bubbles fall from the top of the screen. The user pops them by touching them with their fist.

Core Rules:
Each pop = +1 score and new bubble

Missed bubble = -10% health (configurable)

Powers like F, D, and H fall and can be collected

Game ends when health reaches 0

Game starts after 10s countdown

ğŸ“¦ Required Features
Frame-by-frame video rendering with OpenCV

Fist tracking using MediaPipe (track both hands identically)

Bubble and power object management

Health bar and score overlay

Object hit detection (configurable frame interval)

Object pooling for performance

Configurable parameters via GameConfig

Event-based logic and observers

Game states (INIT, RUNNING, GAME_OVER)

Restart functionality

Run event handling in a separate thread

Thread-safe event queue

Clear class responsibilities and easy extensibility

ğŸ§± Design Patterns to Use
Strategy/Template â†’ For object update/draw logic

Observer â†’ For reacting to game events (score, health, sounds, etc.)

Event Queue + Dispatcher â†’ Centralized event management

Object Pool â†’ For efficient memory and object reuse

State Pattern â†’ Game states (INIT, RUNNING, GAME_OVER)

Factory (optional) â†’ For spawning objects with random configs

ğŸ“ Folder Structure to Generate
graphql
Copy
Edit
bubble_pop/
â”œâ”€â”€ main.py                      # Entry point for the game
â”œâ”€â”€ config/
â”‚   â””â”€â”€ game_config.py           # Game tuning constants
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ game_engine.py           # Main game loop
â”‚   â”œâ”€â”€ game_state.py            # Enum for INIT, RUNNING, GAME_OVER
â”‚   â”œâ”€â”€ game_timer.py            # Countdown timer logic
â”œâ”€â”€ input/
â”‚   â””â”€â”€ hand_tracker.py          # MediaPipe-based hand detection
â”œâ”€â”€ objects/
â”‚   â”œâ”€â”€ base_object.py           # IGameObject and AbstractFallingObject
â”‚   â”œâ”€â”€ bubble.py                # Bubble class
â”‚   â”œâ”€â”€ power.py                 # Power class
â”‚   â”œâ”€â”€ object_manager.py        # Tracks, updates, draws objects
â”‚   â””â”€â”€ object_pool.py           # Reuse bubble/power instances
â”œâ”€â”€ rendering/
â”‚   â””â”€â”€ renderer.py              # OpenCV-based drawing
â”œâ”€â”€ events/
â”‚   â”œâ”€â”€ base_event.py            # GameEvent base class
â”‚   â”œâ”€â”€ event_types.py           # All event subclasses
â”‚   â”œâ”€â”€ event_manager.py         # Dispatch loop + thread
â”‚   â””â”€â”€ observers/
â”‚       â”œâ”€â”€ score_observer.py
â”‚       â”œâ”€â”€ health_observer.py
â”‚       â”œâ”€â”€ sound_observer.py
â”‚       â”œâ”€â”€ spawner_observer.py
â”‚       â””â”€â”€ freeze_observer.py   # For freeze power
â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ sounds/
â”‚   â”‚   â””â”€â”€ pop.wav              # Sound assets
â”‚   â””â”€â”€ fonts/
â”‚       â””â”€â”€ Roboto.ttf           # Optional font
â””â”€â”€ tests/
    â”œâ”€â”€ test_collision.py        # Test for hit detection
    â”œâ”€â”€ test_event_dispatch.py   # Event + observer behavior
    â”œâ”€â”€ test_object_pool.py      # Pool reuse test
    â”œâ”€â”€ test_game_state.py       # Game state transitions
    â””â”€â”€ test_hand_tracker.py     # Valid tracking of fists
ğŸ§ª Generate Minimal Unit Test Stubs
For each key module, create unit test stubs using pytest. The goal is to ensure testability and give developers a foundation to build on.

Include:

test_is_hit_when_fist_inside_bubble()

test_health_decreases_on_miss_event()

test_score_increments_on_hit_event()

test_event_is_dispatched_correctly()

test_event_queue_handles_multiple_events()

test_object_pool_reuses_instances()

test_freeze_power_freezes_all_bubbles()

test_hand_tracker_detects_fist_position()

âœ… Expectations
Modular, object-oriented code following SRP and OCP

Good naming, small methods, logical responsibility split

Document any assumptions inline with comments

No monolithic scripts; use multiple files and clear interfaces

Constants/configs should be easily adjustable

Performance-optimized via pooling and configurable throttling

ğŸ¯ Generate the full Python codebase described above with test stubs and folder structure. Ready to be dropped into a local dev environment.

Let me know if you'd like an actual sample repo scaffold or I can help you paste this into WindSurf or other tool!








You said:
include the low level details of the class in this prompt like you did in the earlier prompt so that code generation tool doesn't hallucinate.


ChatGPT said:
Perfect. Below is your complete WindSurf code generation prompt, now updated to include low-level design details, such as class names, responsibilities, relationships, and key methods. This ensures minimal hallucination and maximum correctness from the code generation tool.

ğŸ§  WindSurf Prompt: Bubble Pop Game â€” Computer Vision Based | Event-Driven | Python | OpenCV + MediaPipe
You are a powerful coding AI. Please generate a modular, extensible, event-driven, object-oriented Python codebase for a real-time game called bubble_pop.

The game is built using:

OpenCV (for video capture & rendering),

MediaPipe (for tracking hands/fists),

and follows OOP, SOLID principles, design patterns, and multithreaded event handling.

ğŸ® Game Description
Bubbles (circles) fall from the top of the screen.

User pops them using their fist (tracked using MediaPipe). Hit = when fist center enters the bubble radius.

Score +1 on each pop. Health -10% (configurable) for each bubble missed.

Powers (F, D, H) fall similarly:

F: Freeze all objects for 5s

D: Destroy all bubbles

H: Restore full health

Game starts after a 10s countdown and ends when health is 0.

Restart is allowed on game over screen.

ğŸ’¡ Design Philosophy
Event-Driven, using the Observer pattern

Threaded: Event processing runs in separate thread

Central GameEngine runs the game loop

Use Object Pooling for memory reuse of game objects

Collision detection rate is configurable (default every 5 frames)

Constants like speed, spawn probability, radius are all configurable

Classes must be small, cohesive, testable

ğŸ“¦ Folder & File Structure
css
Copy
Edit
bubble_pop/
â”œâ”€â”€ main.py
â”œâ”€â”€ config/
â”‚   â””â”€â”€ game_config.py
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ game_engine.py
â”‚   â”œâ”€â”€ game_state.py
â”‚   â””â”€â”€ game_timer.py
â”œâ”€â”€ input/
â”‚   â””â”€â”€ hand_tracker.py
â”œâ”€â”€ objects/
â”‚   â”œâ”€â”€ base_object.py
â”‚   â”œâ”€â”€ bubble.py
â”‚   â”œâ”€â”€ power.py
â”‚   â”œâ”€â”€ object_manager.py
â”‚   â””â”€â”€ object_pool.py
â”œâ”€â”€ rendering/
â”‚   â””â”€â”€ renderer.py
â”œâ”€â”€ events/
â”‚   â”œâ”€â”€ base_event.py
â”‚   â”œâ”€â”€ event_types.py
â”‚   â”œâ”€â”€ event_manager.py
â”‚   â””â”€â”€ observers/
â”‚       â”œâ”€â”€ score_observer.py
â”‚       â”œâ”€â”€ health_observer.py
â”‚       â”œâ”€â”€ sound_observer.py
â”‚       â”œâ”€â”€ spawner_observer.py
â”‚       â””â”€â”€ freeze_observer.py
â”œâ”€â”€ assets/
â”‚   â””â”€â”€ sounds/pop.wav
â””â”€â”€ tests/
    â”œâ”€â”€ test_collision.py
    â”œâ”€â”€ test_event_dispatch.py
    â”œâ”€â”€ test_object_pool.py
    â”œâ”€â”€ test_game_state.py
    â””â”€â”€ test_hand_tracker.py
ğŸ” Low-Level Design Details
âœ… GameEngine
Loop manager: Captures frames, processes game logic, updates state

Key methods:

run(): Starts loop

_process_frame(): Updates objects, handles collision

_check_game_state()

_dispatch_events()

âœ… GameState
Enum with: INIT, RUNNING, GAME_OVER

âœ… HandTracker
Uses MediaPipe

Methods:

get_fist_positions(frame) â†’ List[Point]

draw_fist_indicators(frame, positions)

âœ… AbstractFallingObject (Base class for all objects)
Attributes: x, y, speed, radius, active, type

Methods:

update(dt)

draw(frame)

is_hit(fist_position)

reset(x, y, speed, radius)

âœ… Bubble and Power
Inherit AbstractFallingObject

Power has power_type: Enum (F, D, H)

âœ… ObjectPool
Maintains lists of reusable Bubble and Power instances

Methods:

get_bubble(), get_power()

release(obj)

âœ… ObjectManager
Manages all on-screen objects

Methods:

update_all(dt)

draw_all(frame)

check_hits(fist_positions) â†’ List[HitInfo]

check_misses() â†’ List[MissInfo]

add_object(obj)

âœ… Renderer
Methods:

draw_score(frame, score)

draw_health_bar(frame, health)

draw_timer(frame, seconds_left)

draw_game_over(frame)

âœ… GameTimer
Handles countdown state

Methods:

start(duration)

seconds_left()

is_expired()

âœ… EventManager (Synchronous Dispatch, Threaded)
Thread-safe Queue of events

Methods:

post(event)

start_dispatch_loop()

register_observer(event_type, observer)

âœ… GameEvent + Subclasses
BubbleHitEvent, BubbleMissedEvent, PowerHitEvent, GameOverEvent

âœ… Observers
Each observer implements:

python
Copy
Edit
class IObserver:
    def handle(event: GameEvent)
ScoreObserver: Increments score

HealthObserver: Reduces health, triggers GameOverEvent if needed

SoundObserver: Plays pop sound

SpawnerObserver: Adds new object to screen

FreezeObserver: Temporarily freezes bubble movement

âœ… GameConfig
Constants like:

COLLISION_FRAME_INTERVAL

BUBBLE_RADIUS_RANGE

POWER_CHANCE

MISS_HEALTH_PENALTY

BUBBLE_SPEED_RANGE, etc.

ğŸ§ª Unit Test Stubs (in tests/ folder)
python
Copy
Edit
def test_fist_hits_bubble_within_radius()
def test_health_decreases_on_bubble_miss()
def test_score_increments_on_bubble_hit()
def test_event_is_dispatched_to_registered_observer()
def test_freeze_power_freezes_all_objects()
def test_object_pool_reuses_instances()
def test_game_state_transitions()
def test_hand_tracker_detects_fist_position()
âœ… Summary
Use multiple files, not one monolithic script

Code must be modular, SOLID-compliant, readable

Configurable constants, extensible observers

Game loop must run fast, rendering every frame

Event dispatching must not block the main thread

ğŸ¯ Generate the full codebase described above with all class files, tests, and structure. Do not merge files. Output ready-to-run Python project.